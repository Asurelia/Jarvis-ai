/**
 * üéØ Tests E2E pour l'interface JARVIS
 * Tests end-to-end complets de l'exp√©rience utilisateur
 */

import { test, expect } from '@playwright/test';

// Configuration des tests
test.describe('ü§ñ Interface JARVIS - Tests E2E', () => {
  let page;
  
  test.beforeEach(async ({ page: testPage }) => {
    page = testPage;
    
    // Naviguer vers l'application
    await page.goto('/');
    
    // Attendre que l'application soit charg√©e
    await page.waitForSelector('[data-testid="app-container"]', { 
      timeout: 15000,
      state: 'visible' 
    });
  });

  test.describe('üé® Interface Utilisateur', () => {
    
    test('doit charger la page d\'accueil correctement', async () => {
      // V√©rifier le titre de la page
      await expect(page).toHaveTitle(/JARVIS/i);
      
      // V√©rifier les √©l√©ments principaux
      await expect(page.getByTestId('app-container')).toBeVisible();
      await expect(page.getByRole('main')).toBeVisible();
      
      // V√©rifier le th√®me sombre
      const body = page.locator('body');
      await expect(body).toHaveCSS('background-color', /rgb\(13, 20, 33\)|rgb\(26, 37, 47\)/);
    });

    test('doit afficher la barre de navigation', async () => {
      // V√©rifier la pr√©sence de la navigation
      const nav = page.getByRole('navigation').or(page.locator('[data-testid="navigation"]'));
      await expect(nav).toBeVisible();
      
      // V√©rifier les √©l√©ments de navigation principaux
      await expect(page.getByText('Chat', { exact: false })).toBeVisible();
      await expect(page.getByText('Voice', { exact: false })).toBeVisible();
      await expect(page.getByText('Vision', { exact: false })).toBeVisible();
    });

    test('doit √™tre responsive', async () => {
      // Test desktop
      await page.setViewportSize({ width: 1920, height: 1080 });
      await expect(page.getByTestId('app-container')).toBeVisible();
      
      // Test tablet
      await page.setViewportSize({ width: 768, height: 1024 });
      await page.waitForTimeout(500);
      await expect(page.getByTestId('app-container')).toBeVisible();
      
      // Test mobile
      await page.setViewportSize({ width: 375, height: 667 });
      await page.waitForTimeout(500);
      await expect(page.getByTestId('app-container')).toBeVisible();
    });
  });

  test.describe('üí¨ Interface de Chat', () => {
    
    test('doit ouvrir la fen√™tre de chat', async () => {
      // Cliquer sur le bouton chat
      const chatButton = page.getByRole('button', { name: /chat/i })
        .or(page.getByTestId('chat-button'))
        .or(page.locator('[data-testid*="chat"]').first());
      
      await chatButton.click();
      
      // V√©rifier que la fen√™tre de chat s'ouvre
      const chatWindow = page.getByTestId('chat-window')
        .or(page.locator('.chat-window'))
        .or(page.getByRole('dialog'));
      
      await expect(chatWindow).toBeVisible();
    });

    test('doit permettre d\'envoyer un message', async () => {
      // Ouvrir le chat
      await page.getByTestId('chat-button').or(page.getByRole('button', { name: /chat/i })).click();
      
      // Trouver le champ de saisie
      const input = page.getByRole('textbox', { name: /message/i })
        .or(page.getByPlaceholder(/tapez votre message/i))
        .or(page.locator('input[type="text"]').last())
        .or(page.locator('textarea').last());
      
      // Saisir un message
      const testMessage = 'Bonjour JARVIS, comment allez-vous ?';
      await input.fill(testMessage);
      
      // Envoyer le message
      const sendButton = page.getByRole('button', { name: /envoyer|send/i })
        .or(page.getByTestId('send-button'))
        .or(page.keyboard.press('Enter'));
      
      if (sendButton && typeof sendButton.click === 'function') {
        await sendButton.click();
      } else {
        await page.keyboard.press('Enter');
      }
      
      // V√©rifier que le message appara√Æt dans l'historique
      await expect(page.getByText(testMessage)).toBeVisible();
    });

    test('doit afficher les r√©ponses de JARVIS', async () => {
      // Envoyer un message et attendre la r√©ponse
      await page.getByTestId('chat-button').or(page.getByRole('button', { name: /chat/i })).click();
      
      const input = page.getByRole('textbox').last();
      await input.fill('Test');
      await page.keyboard.press('Enter');
      
      // Attendre une r√©ponse (timeout plus long pour la g√©n√©ration)
      await expect(page.getByText(/jarvis|ia|intelligence/i)).toBeVisible({ timeout: 30000 });
    });
  });

  test.describe('üéôÔ∏è Interface Vocale', () => {
    
    test('doit afficher les contr√¥les vocaux', async () => {
      // Naviguer vers l'interface vocale
      await page.getByText('Voice').or(page.getByTestId('voice-tab')).click();
      
      // V√©rifier la pr√©sence des contr√¥les
      const micButton = page.getByRole('button', { name: /micro|record/i })
        .or(page.getByTestId('mic-button'));
      
      await expect(micButton).toBeVisible();
    });

    test('doit g√©rer les permissions audio', async () => {
      // Simuler l'accord de permission
      await page.context().grantPermissions(['microphone']);
      
      await page.getByText('Voice').or(page.getByTestId('voice-tab')).click();
      
      // Tenter d'utiliser le microphone
      const micButton = page.getByTestId('mic-button')
        .or(page.getByRole('button', { name: /micro/i }));
      
      await micButton.click();
      
      // V√©rifier que l'enregistrement d√©marre
      await expect(page.getByText(/enregistrement|recording/i)).toBeVisible({ timeout: 5000 });
    });
  });

  test.describe('üëÅÔ∏è Interface Vision', () => {
    
    test('doit afficher l\'interface vision', async () => {
      await page.getByText('Vision').or(page.getByTestId('vision-tab')).click();
      
      // V√©rifier les √©l√©ments de vision
      const visionContainer = page.getByTestId('vision-container')
        .or(page.locator('.vision-interface'));
      
      await expect(visionContainer).toBeVisible();
    });

    test('doit permettre la capture d\'√©cran', async () => {
      // Accorder les permissions
      await page.context().grantPermissions(['camera']);
      
      await page.getByText('Vision').or(page.getByTestId('vision-tab')).click();
      
      const captureButton = page.getByRole('button', { name: /capture|screenshot/i })
        .or(page.getByTestId('capture-button'));
      
      if (await captureButton.isVisible()) {
        await captureButton.click();
        
        // V√©rifier que la capture est trait√©e
        await expect(page.getByText(/capture|analyse/i)).toBeVisible({ timeout: 10000 });
      }
    });
  });

  test.describe('üß† Modules Avanc√©s', () => {
    
    test('doit afficher le module d\'intelligence cognitive', async () => {
      // Chercher le module d'IA cognitive
      const cognitiveModule = page.getByTestId('cognitive-module')
        .or(page.getByText(/intelligence.*cognitive/i))
        .or(page.locator('[class*="cognitive"]').first());
      
      if (await cognitiveModule.isVisible()) {
        await expect(cognitiveModule).toBeVisible();
      }
    });

    test('doit afficher la sph√®re 3D', async () => {
      // Chercher la sph√®re 3D
      const sphere3D = page.getByTestId('sphere-3d')
        .or(page.locator('canvas'))
        .or(page.locator('[class*="sphere"]'));
      
      if (await sphere3D.isVisible()) {
        await expect(sphere3D).toBeVisible();
        
        // V√©rifier que l'animation fonctionne
        await page.waitForTimeout(1000);
        const boundingBox1 = await sphere3D.boundingBox();
        await page.waitForTimeout(1000);
        const boundingBox2 = await sphere3D.boundingBox();
        
        // L'animation peut changer la position ou d'autres propri√©t√©s
        expect(boundingBox1).toBeDefined();
        expect(boundingBox2).toBeDefined();
      }
    });

    test('doit afficher le moniteur de performance', async () => {
      const perfMonitor = page.getByTestId('performance-monitor')
        .or(page.getByText(/performance|fps|cpu/i))
        .or(page.locator('[class*="performance"]').first());
      
      if (await perfMonitor.isVisible()) {
        await expect(perfMonitor).toBeVisible();
        
        // V√©rifier que les m√©triques se mettent √† jour
        await page.waitForTimeout(2000);
        await expect(perfMonitor).toContainText(/\d+/); // Contient des chiffres
      }
    });
  });

  test.describe('üîó Connectivit√© et WebSocket', () => {
    
    test('doit √©tablir une connexion WebSocket', async () => {
      // √âcouter les √©v√©nements WebSocket
      let wsConnected = false;
      
      page.on('websocket', ws => {
        wsConnected = true;
        ws.on('framesent', event => console.log('WS Frame sent:', event.payload));
        ws.on('framereceived', event => console.log('WS Frame received:', event.payload));
      });
      
      // D√©clencher une action qui utilise WebSocket
      const chatButton = page.getByTestId('chat-button').first();
      if (await chatButton.isVisible()) {
        await chatButton.click();
        
        // Attendre un peu pour la connexion WebSocket
        await page.waitForTimeout(2000);
        
        // V√©rifier dans les DevTools Network
        const wsRequests = await page.evaluate(() => {
          return performance.getEntriesByType('resource')
            .filter(entry => entry.name.includes('ws://') || entry.name.includes('wss://'));
        });
        
        expect(wsRequests.length).toBeGreaterThan(0);
      }
    });

    test('doit g√©rer les erreurs de connexion', async () => {
      // Simuler une perte de connexion r√©seau
      await page.context().setOffline(true);
      
      // Tenter d'interagir avec l'application
      const chatButton = page.getByTestId('chat-button').first();
      if (await chatButton.isVisible()) {
        await chatButton.click();
        
        // V√©rifier qu'un message d'erreur appara√Æt
        await expect(page.getByText(/connexion|erreur|offline/i))
          .toBeVisible({ timeout: 10000 });
      }
      
      // Restaurer la connexion
      await page.context().setOffline(false);
    });
  });

  test.describe('‚ö° Performance et Accessibilit√©', () => {
    
    test('doit charger rapidement', async () => {
      const startTime = Date.now();
      
      await page.goto('/', { waitUntil: 'domcontentloaded' });
      await page.waitForSelector('[data-testid="app-container"]');
      
      const loadTime = Date.now() - startTime;
      expect(loadTime).toBeLessThan(5000); // Moins de 5 secondes
    });

    test('doit √™tre accessible au clavier', async () => {
      // Navigation par tabulation
      await page.keyboard.press('Tab');
      let focusedElement = await page.locator(':focus').first();
      await expect(focusedElement).toBeVisible();
      
      // Continuer la navigation
      for (let i = 0; i < 5; i++) {
        await page.keyboard.press('Tab');
        focusedElement = await page.locator(':focus').first();
        
        if (await focusedElement.isVisible()) {
          await expect(focusedElement).toBeVisible();
        }
      }
    });

    test('doit avoir des contrastes suffisants', async () => {
      // V√©rifier les contrastes principaux
      const textElements = page.locator('h1, h2, h3, p, span, button').first();
      
      if (await textElements.isVisible()) {
        const color = await textElements.evaluate(el => {
          return window.getComputedStyle(el).color;
        });
        
        // V√©rifier que la couleur n'est pas trop proche du fond
        expect(color).not.toBe('rgb(0, 0, 0)');
        expect(color).not.toBe('rgb(13, 20, 33)');
      }
    });
  });

  test.describe('üì± Tests Multi-plateforme', () => {
    
    test('doit fonctionner sur diff√©rentes r√©solutions', async () => {
      const resolutions = [
        { width: 1920, height: 1080 }, // Full HD
        { width: 1366, height: 768 },  // HD
        { width: 1024, height: 768 },  // Tablet
        { width: 375, height: 812 },   // Mobile
      ];
      
      for (const resolution of resolutions) {
        await page.setViewportSize(resolution);
        await page.waitForTimeout(500);
        
        // V√©rifier que l'interface reste utilisable
        await expect(page.getByTestId('app-container')).toBeVisible();
        
        // V√©rifier qu'il n'y a pas d'√©l√©ments d√©bordants
        const overflowElements = await page.$$eval('*', elements => {
          return elements.filter(el => {
            const rect = el.getBoundingClientRect();
            return rect.right > window.innerWidth || rect.bottom > window.innerHeight;
          }).length;
        });
        
        expect(overflowElements).toBeLessThan(5); // Tol√©rance pour quelques √©l√©ments
      }
    });
  });

  // Nettoyage apr√®s chaque test
  test.afterEach(async ({ page }) => {
    // Fermer les connexions WebSocket ouvertes
    await page.evaluate(() => {
      if (window.ws) {
        window.ws.close();
      }
    });
    
    // Capturer une screenshot en cas d'√©chec
    if (test.info().status !== 'passed') {
      await page.screenshot({ 
        path: `test-results/failed-${test.info().title.replace(/\s+/g, '-')}.png`,
        fullPage: true 
      });
    }
  });
});