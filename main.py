#!/usr/bin/env python3
"""
ü§ñ JARVIS - Agent IA Autonome pour Windows
Script principal avec toutes les fonctionnalit√©s Phase 4

Usage:
    python main.py                    # Mode interactif complet
    python main.py --demo            # Mode d√©monstration
    python main.py --test            # Tests des modules
    python main.py --voice           # Mode vocal
    python main.py --autocomplete    # Test autocompl√©tion
    python main.py --tools           # Test syst√®me d'outils
    python main.py --command "..."   # Commande directe
"""
import asyncio
import argparse
import sys
import time
from pathlib import Path
from typing import Dict, Any
import json
from loguru import logger

# Ajouter le r√©pertoire racine au path
sys.path.insert(0, str(Path(__file__).parent))

# Imports des modules JARVIS Phase 1
from core.agent import JarvisAgent, create_agent
from core.vision.screen_capture import ScreenCapture, quick_screenshot
from core.vision.ocr_engine import OCREngine, quick_ocr
from core.vision.visual_analysis import VisualAnalyzer, quick_screen_analysis
from core.control.mouse_controller import MouseController, quick_click
from core.control.keyboard_controller import KeyboardController, quick_type
from core.control.app_detector import AppDetector, get_current_app
from core.ai.ollama_service import OllamaService, quick_chat
from core.ai.action_planner import ActionPlanner, quick_plan
from core.ai.action_executor import ActionExecutor
from core.ai.memory_system import MemorySystem

# Imports des modules JARVIS Phase 2
from core.voice.voice_interface import VoiceInterface, VoiceInterfaceConfig
from autocomplete.global_autocomplete import GlobalAutocomplete, AutocompleteConfig
from autocomplete.suggestion_engine import SuggestionEngine
from autocomplete.overlay_ui import OverlayUI

# Imports des modules JARVIS Phase 4 - Tools System
from tools.tool_manager import tool_manager
from tools.mcp_server import mcp_server

from config.amd_gpu import configure_amd_gpu, OLLAMA_CONFIG

class JarvisDemo:
    """Classe de d√©monstration de JARVIS"""
    
    def __init__(self):
        self.modules = {}
        self.agent = None
        
    async def initialize_all_modules(self):
        """Initialise tous les modules JARVIS (Phase 1 + Phase 2)"""
        logger.info("üöÄ Initialisation compl√®te de JARVIS Phase 2...")
        
        try:
            # Configuration GPU AMD
            configure_amd_gpu()
            
            # === MODULES PHASE 1 ===
            
            # Vision
            logger.info("üì∏ Initialisation des modules de vision...")
            self.modules['screen_capture'] = ScreenCapture()
            await self.modules['screen_capture'].initialize()
            
            self.modules['ocr'] = OCREngine()
            await self.modules['ocr'].initialize()
            
            self.modules['vision_analyzer'] = VisualAnalyzer()
            await self.modules['vision_analyzer'].initialize()
            
            # Contr√¥le
            logger.info("üéÆ Initialisation des modules de contr√¥le...")
            self.modules['mouse'] = MouseController(sandbox_mode=True)
            await self.modules['mouse'].initialize()
            
            self.modules['keyboard'] = KeyboardController(sandbox_mode=True)
            await self.modules['keyboard'].initialize()
            
            self.modules['app_detector'] = AppDetector()
            await self.modules['app_detector'].initialize()
            
            # IA Core
            logger.info("ü§ñ Initialisation des modules IA...")
            self.modules['ollama'] = OllamaService()
            await self.modules['ollama'].initialize()
            
            self.modules['planner'] = ActionPlanner(self.modules['ollama'])
            
            # === MODULES PHASE 2 ===
            
            # M√©moire persistante
            logger.info("üß† Initialisation du syst√®me de m√©moire...")
            self.modules['memory'] = MemorySystem()
            memory_initialized = await self.modules['memory'].initialize()
            if memory_initialized:
                # Configurer le service Ollama pour les r√©sum√©s
                if 'ollama' in self.modules:
                    self.modules['memory'].set_ollama_service(self.modules['ollama'])
                logger.success("‚úÖ Syst√®me de m√©moire pr√™t")
            else:
                logger.warning("‚ö†Ô∏è Syst√®me de m√©moire non disponible")
            
            # Ex√©cuteur d'actions
            logger.info("‚ö° Initialisation de l'ex√©cuteur d'actions...")
            self.modules['executor'] = ActionExecutor()
            await self.modules['executor'].initialize(self.modules)
            
            # Interface vocale
            logger.info("üé§ Initialisation de l'interface vocale...")
            try:
                self.modules['voice'] = VoiceInterface()
                voice_initialized = await self.modules['voice'].initialize()
                if voice_initialized:
                    logger.success("‚úÖ Interface vocale pr√™te")
                else:
                    logger.warning("‚ö†Ô∏è Interface vocale non disponible")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Interface vocale non disponible: {e}")
                self.modules['voice'] = None
            
            # Autocompl√©tion globale
            logger.info("‚ö° Initialisation de l'autocompl√©tion globale...")
            try:
                self.modules['suggestion_engine'] = SuggestionEngine(self.modules['ollama'])
                await self.modules['suggestion_engine'].initialize()
                
                self.modules['autocomplete'] = GlobalAutocomplete()
                autocomplete_initialized = await self.modules['autocomplete'].initialize()
                
                if autocomplete_initialized:
                    # Configurer les callbacks
                    async def suggestion_callback(context):
                        return await self._generate_autocomplete_suggestions(context)
                    
                    async def context_callback(event):
                        await self._handle_autocomplete_event(event)
                    
                    self.modules['autocomplete'].set_suggestion_callback(suggestion_callback)
                    self.modules['autocomplete'].set_context_callback(context_callback)
                    
                    logger.success("‚úÖ Autocompl√©tion globale pr√™te")
                else:
                    logger.warning("‚ö†Ô∏è Autocompl√©tion globale non disponible")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Autocompl√©tion non disponible: {e}")
                self.modules['autocomplete'] = None
            
            # === MODULES PHASE 4 - TOOLS SYSTEM ===
            
            # Gestionnaire d'outils
            logger.info("üõ†Ô∏è Initialisation du syst√®me d'outils...")
            try:
                tools_initialized = await tool_manager.initialize()
                if tools_initialized:
                    self.modules['tool_manager'] = tool_manager
                    logger.success(f"‚úÖ Syst√®me d'outils pr√™t avec {len(tool_manager.registry.tools)} outils")
                else:
                    logger.warning("‚ö†Ô∏è Syst√®me d'outils non disponible")
                    self.modules['tool_manager'] = None
            except Exception as e:
                logger.error(f"‚ùå Erreur initialisation outils: {e}")
                self.modules['tool_manager'] = None
            
            # Serveur MCP
            logger.info("üîå Initialisation du serveur MCP...")
            try:
                self.modules['mcp_server'] = mcp_server
                logger.success("‚úÖ Serveur MCP pr√™t")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Serveur MCP non disponible: {e}")
                self.modules['mcp_server'] = None
            
            # Agent principal
            logger.info("üéØ Cr√©ation de l'agent JARVIS...")
            self.agent = await create_agent()
            
            logger.success("‚úÖ JARVIS Phase 2 compl√®tement initialis√© et pr√™t!")
            logger.info("üåü Nouvelles fonctionnalit√©s disponibles:")
            logger.info("  üé§ Interface vocale avec Whisper + Edge-TTS")
            logger.info("  ‚ö° Autocompl√©tion globale temps r√©el")
            logger.info("  üß† M√©moire persistante avec ChromaDB") 
            logger.info("  üöÄ Ex√©cution automatique d'actions")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur lors de l'initialisation: {e}")
            return False
    
    # === M√©thodes pour les nouvelles fonctionnalit√©s Phase 2 ===
    
    async def _generate_autocomplete_suggestions(self, context):
        """G√©n√®re des suggestions d'autocompl√©tion"""
        try:
            if self.modules['suggestion_engine']:
                from autocomplete.suggestion_engine import SuggestionContext
                
                suggestion_context = SuggestionContext(
                    word=context["current_word"],
                    app_name=context["app_name"],
                    field_type=context["field_type"],
                    language=context.get("language", "fr"),
                    line_context=context["current_line"],
                    previous_words=context.get("previous_words", [])
                )
                
                suggestions = await self.modules['suggestion_engine'].generate_suggestions(suggestion_context, 5)
                return [s.text for s in suggestions]
            
            return []
        except Exception as e:
            logger.debug(f"Erreur g√©n√©ration suggestions: {e}")
            return []
    
    async def _handle_autocomplete_event(self, event):
        """G√®re les √©v√©nements d'autocompl√©tion"""
        try:
            action = event["action"]
            
            if action == "show_suggestions":
                suggestions = event["suggestions"]
                context = event["context"]
                logger.debug(f"üí° Suggestions: {suggestions} pour '{context.current_text}'")
                
                # Afficher l'overlay UI avec les suggestions
                if hasattr(self, 'overlay_ui') and self.overlay_ui and suggestions:
                    try:
                        self.overlay_ui.show_suggestions(suggestions, context)
                    except Exception as e:
                        logger.warning(f"‚ö†Ô∏è Impossible d'afficher overlay: {e}")
                
            elif action == "suggestion_accepted":
                suggestion = event["suggestion"]
                original = event["original"]
                logger.info(f"‚úÖ Suggestion accept√©e: '{original}' -> '{suggestion}'")
                
                # Apprendre de l'acceptation
                if self.modules['suggestion_engine']:
                    from autocomplete.suggestion_engine import SuggestionContext
                    context = SuggestionContext(word=original, app_name="", field_type="text", language="fr", line_context="")
                    self.modules['suggestion_engine'].learn_from_acceptance(context, suggestion)
        
        except Exception as e:
            logger.debug(f"Erreur √©v√©nement autocompl√©tion: {e}")
    
    async def run_voice_mode(self):
        """Lance le mode vocal interactif"""
        if not self.modules.get('voice'):
            logger.error("‚ùå Interface vocale non disponible")
            return
        
        logger.info("üé§ D√©marrage du mode vocal JARVIS...")
        
        # Configurer le callback de commande vocale
        async def voice_command_callback(command: str) -> str:
            """Traite les commandes vocales"""
            try:
                # D√©marrer une conversation en m√©moire
                if self.modules.get('memory'):
                    conv_id = self.modules['memory'].start_conversation({"mode": "voice"})
                    self.modules['memory'].add_message_to_conversation(conv_id, "user", command)
                
                # Planifier et ex√©cuter l'action
                if self.modules.get('planner') and self.modules.get('executor'):
                    sequence = await self.modules['planner'].parse_natural_command(command)
                    
                    if sequence and sequence.actions:
                        logger.info(f"üìã S√©quence planifi√©e: {len(sequence.actions)} actions")
                        
                        # Demander confirmation vocale
                        confirmation = f"Je vais ex√©cuter {len(sequence.actions)} actions pour: {sequence.description}. Voulez-vous continuer ?"
                        await self.modules['voice'].speak(confirmation)
                        
                        # √âcouter la r√©ponse
                        response = await self.modules['voice'].listen_for_command()
                        
                        if response and ("oui" in response.lower() or "ok" in response.lower() or "yes" in response.lower()):
                            # Ex√©cuter la s√©quence
                            result = await self.modules['executor'].execute_sequence(sequence)
                            
                            if result["success"]:
                                response_text = f"Commande ex√©cut√©e avec succ√®s en {result['execution_time']:.1f} secondes."
                            else:
                                response_text = f"Erreur lors de l'ex√©cution: {result.get('error', 'Erreur inconnue')}"
                        else:
                            response_text = "Commande annul√©e."
                    else:
                        response_text = "Je n'ai pas pu planifier cette action."
                else:
                    # R√©ponse conversationnelle via Ollama
                    if self.modules.get('ollama'):
                        ollama_response = await self.modules['ollama'].chat(command)
                        response_text = ollama_response.content if ollama_response.success else "Je n'ai pas pu traiter votre demande."
                    else:
                        response_text = "Syst√®me de traitement non disponible."
                
                # Enregistrer la r√©ponse en m√©moire
                if self.modules.get('memory') and 'conv_id' in locals():
                    self.modules['memory'].add_message_to_conversation(conv_id, "assistant", response_text)
                
                return response_text
                
            except Exception as e:
                logger.error(f"‚ùå Erreur traitement commande vocale: {e}")
                return f"Erreur lors du traitement: {str(e)}"
        
        # Configurer les callbacks
        self.modules['voice'].set_command_callback(voice_command_callback)
        
        # D√©marrer l'activation vocale
        try:
            await self.modules['voice'].start_voice_activation()
        except KeyboardInterrupt:
            logger.info("‚èπÔ∏è Mode vocal arr√™t√© par l'utilisateur")
        finally:
            self.modules['voice'].stop_voice_activation()
    
    async def test_autocomplete_system(self):
        """Test du syst√®me d'autocompl√©tion"""
        if not self.modules.get('autocomplete'):
            logger.error("‚ùå Syst√®me d'autocompl√©tion non disponible")
            return
        
        logger.info("üß™ Test du syst√®me d'autocompl√©tion globale")
        logger.info("Tapez dans n'importe quelle application pour tester l'autocompl√©tion")
        logger.info("Les suggestions appara√Ætront automatiquement")
        logger.info("Ctrl+C pour arr√™ter")
        
        try:
            # Le syst√®me d'autocompl√©tion fonctionne en arri√®re-plan
            while True:
                await asyncio.sleep(1)
                
                # Afficher les stats p√©riodiquement
                stats = self.modules['autocomplete'].get_stats()
                if stats["keys_processed"] > 0 and stats["keys_processed"] % 100 == 0:
                    logger.info(f"üìä {stats['keys_processed']} touches trait√©es, {stats['suggestions_generated']} suggestions")
        
        except KeyboardInterrupt:
            logger.info("‚èπÔ∏è Test autocompl√©tion arr√™t√©")
            await self.modules['autocomplete'].shutdown()
    
    async def test_tools_system(self):
        """Test du syst√®me d'outils"""
        if not self.modules.get('tool_manager'):
            logger.error("‚ùå Syst√®me d'outils non disponible")
            return
        
        logger.info("üõ†Ô∏è Test du syst√®me d'outils JARVIS")
        
        try:
            # Afficher les statistiques
            stats = self.modules['tool_manager'].get_stats()
            logger.info(f"üìä {stats['tools_available']} outils disponibles")
            
            # Lister les outils par cat√©gorie
            for category, count in stats['categories'].items():
                if count > 0:
                    logger.info(f"  {category}: {count} outils")
            
            # Test d'ex√©cution d'outils
            logger.info("üß™ Tests d'ex√©cution...")
            
            # Test 1: Lecture du fichier courant
            logger.info("1. Test lecture de fichier...")
            result = await self.modules['tool_manager'].execute_tool("FileReadTool", {
                "filepath": __file__,
                "max_lines": 5
            })
            if result.success:
                logger.success(f"‚úÖ Fichier lu: {len(result.data)} caract√®res")
            else:
                logger.error(f"‚ùå Erreur: {result.error}")
            
            # Test 2: Informations syst√®me
            logger.info("2. Test informations syst√®me...")
            result = await self.modules['tool_manager'].execute_tool("SystemInfoTool", {
                "include_network": False,
                "include_disks": False
            })
            if result.success:
                logger.success(f"‚úÖ Infos syst√®me r√©cup√©r√©es")
                logger.info(f"  Syst√®me: {result.data['platform']['system']}")
                logger.info(f"  RAM: {result.data['memory']['total_gb']} GB")
            else:
                logger.error(f"‚ùå Erreur: {result.error}")
            
            # Test 3: Recherche d'outils
            logger.info("3. Test recherche d'outils...")
            matches = self.modules['tool_manager'].search_tools("lire fichier", max_results=3)
            logger.success(f"‚úÖ {len(matches)} outils trouv√©s pour 'lire fichier'")
            for match in matches:
                tool_info = match["tool"]
                similarity = match["similarity"]
                logger.info(f"  - {tool_info['display_name']} (similarit√©: {similarity:.2f})")
            
            # Test 4: Ex√©cution par requ√™te
            logger.info("4. Test ex√©cution par requ√™te...")
            result = await self.modules['tool_manager'].execute_tool_by_query(
                "obtenir les informations du syst√®me"
            )
            if result.success:
                logger.success("‚úÖ Outil ex√©cut√© via requ√™te naturelle")
            else:
                logger.error(f"‚ùå Erreur: {result.error}")
            
            # Statistiques finales
            final_stats = self.modules['tool_manager'].get_stats()
            logger.info("üìä Statistiques finales:")
            logger.info(f"  Outils ex√©cut√©s: {final_stats['tools_executed']}")
            logger.info(f"  Succ√®s: {final_stats['executions_successful']}")
            logger.info(f"  √âchecs: {final_stats['executions_failed']}")
            if final_stats['tools_executed'] > 0:
                logger.info(f"  Taux de succ√®s: {final_stats['success_rate']:.1%}")
                logger.info(f"  Temps moyen: {final_stats['avg_execution_time']:.2f}s")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur durant le test des outils: {e}")
    
    async def run_basic_tests(self):
        """Ex√©cute les tests de base de tous les modules"""
        logger.info("üß™ Lancement des tests de base...")
        
        results = {}
        
        # Test capture d'√©cran
        try:
            logger.info("üì∏ Test capture d'√©cran...")
            screenshot = await self.modules['screen_capture'].capture()
            if screenshot:
                logger.success("‚úÖ Capture d'√©cran OK")
                results['screenshot'] = True
                
                # Sauvegarder pour inspection
                screenshot.save("test_screenshot.png")
                logger.info("üíæ Capture sauv√©e: test_screenshot.png")
            else:
                raise Exception("Capture √©chou√©e")
        except Exception as e:
            logger.error(f"‚ùå Test capture d'√©cran √©chou√©: {e}")
            results['screenshot'] = False
        
        # Test OCR
        try:
            logger.info("üîç Test OCR...")
            if results.get('screenshot') and 'screen_capture' in self.modules:
                screenshot = await self.modules['screen_capture'].capture()
                if screenshot:
                    ocr_result = await self.modules['ocr'].extract_text(screenshot.image, "auto")
                    if ocr_result.all_text:
                        logger.success(f"‚úÖ OCR OK - {len(ocr_result.words)} mots d√©tect√©s")
                        logger.info(f"üìù Texte √©chantillon: {ocr_result.all_text[:100]}...")
                        results['ocr'] = True
                    else:
                        logger.warning("‚ö†Ô∏è  OCR OK mais aucun texte d√©tect√©")
                        results['ocr'] = True
        except Exception as e:
            logger.error(f"‚ùå Test OCR √©chou√©: {e}")
            results['ocr'] = False
        
        # Test analyse visuelle
        try:
            logger.info("üëÅÔ∏è  Test analyse visuelle...")
            if results.get('screenshot') and 'screen_capture' in self.modules:
                screenshot = await self.modules['screen_capture'].capture()
                if screenshot:
                    analysis = await self.modules['vision_analyzer'].analyze_screen(screenshot.image)
                    logger.success(f"‚úÖ Analyse visuelle OK - {len(analysis.ui_elements)} √©l√©ments d√©tect√©s")
                    logger.info(f"üìã Description: {analysis.description[:100]}...")
                    results['visual_analysis'] = True
        except Exception as e:
            logger.error(f"‚ùå Test analyse visuelle √©chou√©: {e}")
            results['visual_analysis'] = False
        
        # Test d√©tection d'applications
        try:
            logger.info("üîç Test d√©tection d'applications...")
            apps = await self.modules['app_detector'].get_running_applications()
            if apps:
                logger.success(f"‚úÖ D√©tection apps OK - {len(apps)} applications trouv√©es")
                
                # Afficher les top 5
                for i, app in enumerate(apps[:5]):
                    status = "üü¢" if app.is_active else "‚ö™"
                    logger.info(f"  {status} {app.name} ({app.memory_usage}MB)")
                
                results['app_detection'] = True
            else:
                raise Exception("Aucune application d√©tect√©e")
        except Exception as e:
            logger.error(f"‚ùå Test d√©tection apps √©chou√©: {e}")
            results['app_detection'] = False
        
        # Test Ollama (si disponible)
        try:
            logger.info("ü§ñ Test Ollama...")
            if self.modules['ollama'].is_available:
                response = await self.modules['ollama'].chat("Bonjour JARVIS, r√©ponds juste 'OK' pour le test")
                if response.success:
                    logger.success(f"‚úÖ Ollama OK - R√©ponse: {response.content[:50]}...")
                    results['ollama'] = True
                else:
                    raise Exception(f"Erreur r√©ponse: {response.error}")
            else:
                logger.warning("‚ö†Ô∏è  Ollama non disponible")
                results['ollama'] = False
        except Exception as e:
            logger.error(f"‚ùå Test Ollama √©chou√©: {e}")
            results['ollama'] = False
        
        # Test planification
        try:
            logger.info("üìã Test planification...")
            sequence = await self.modules['planner'].parse_natural_command("Take a screenshot")
            if sequence and sequence.actions:
                logger.success(f"‚úÖ Planification OK - {len(sequence.actions)} actions planifi√©es")
                for i, action in enumerate(sequence.actions):
                    logger.info(f"  {i+1}. {action.type.value}: {action.description}")
                results['planning'] = True
            else:
                raise Exception("Aucune action planifi√©e")
        except Exception as e:
            logger.error(f"‚ùå Test planification √©chou√©: {e}")
            results['planning'] = False
        
        # === TESTS PHASE 2 ===
        
        # Test ex√©cuteur d'actions
        try:
            logger.info("‚ö° Test ex√©cuteur d'actions...")
            if self.modules['executor']:
                from core.ai.action_planner import Action, ActionType, ActionSequence
                
                test_action = Action(
                    type=ActionType.SCREENSHOT,
                    description="Test screenshot",
                    parameters={}
                )
                
                test_sequence = ActionSequence(
                    id="test_executor",
                    name="Test ex√©cuteur",
                    description="Test de l'ex√©cuteur d'actions",
                    actions=[test_action]
                )
                
                result = await self.modules['executor'].execute_sequence(test_sequence)
                
                if result["success"]:
                    logger.success(f"‚úÖ Ex√©cuteur OK - {result['actions_executed']} actions ex√©cut√©es")
                    results['executor'] = True
                else:
                    raise Exception(result.get("error", "√âchec ex√©cution"))
            else:
                raise Exception("Ex√©cuteur non disponible")
        except Exception as e:
            logger.error(f"‚ùå Test ex√©cuteur √©chou√©: {e}")
            results['executor'] = False
        
        # Test m√©moire
        try:
            logger.info("üß† Test syst√®me de m√©moire...")
            if self.modules['memory']:
                # Test de conversation
                conv_id = self.modules['memory'].start_conversation({"test": True})
                self.modules['memory'].add_message_to_conversation(conv_id, "user", "Test message")
                self.modules['memory'].add_message_to_conversation(conv_id, "assistant", "Test response")
                
                summary = await self.modules['memory'].end_conversation(conv_id)
                
                if summary:
                    logger.success(f"‚úÖ M√©moire OK - Conversation sauv√©e: {summary[:50]}...")
                    results['memory'] = True
                else:
                    raise Exception("Pas de r√©sum√© g√©n√©r√©")
            else:
                logger.warning("‚ö†Ô∏è Syst√®me de m√©moire non disponible")
                results['memory'] = False
        except Exception as e:
            logger.error(f"‚ùå Test m√©moire √©chou√©: {e}")
            results['memory'] = False
        
        # Test interface vocale
        try:
            logger.info("üé§ Test interface vocale...")
            if self.modules['voice']:
                # Test de synth√®se vocale simple
                await self.modules['voice'].speak("Test de l'interface vocale JARVIS.")
                logger.success("‚úÖ Interface vocale OK - TTS fonctionnel")
                results['voice'] = True
            else:
                logger.warning("‚ö†Ô∏è Interface vocale non disponible")
                results['voice'] = False
        except Exception as e:
            logger.error(f"‚ùå Test interface vocale √©chou√©: {e}")
            results['voice'] = False
        
        # Test moteur de suggestions
        try:
            logger.info("üí° Test moteur de suggestions...")
            if self.modules['suggestion_engine']:
                from autocomplete.suggestion_engine import SuggestionContext
                
                test_context = SuggestionContext(
                    word="test",
                    app_name="notepad.exe",
                    field_type="text",
                    language="fr",
                    line_context="This is a test"
                )
                
                suggestions = await self.modules['suggestion_engine'].generate_suggestions(test_context)
                
                if suggestions:
                    logger.success(f"‚úÖ Moteur suggestions OK - {len(suggestions)} suggestions g√©n√©r√©es")
                    results['suggestions'] = True
                else:
                    logger.warning("‚ö†Ô∏è Aucune suggestion g√©n√©r√©e")
                    results['suggestions'] = True  # Pas forc√©ment un √©chec
            else:
                logger.warning("‚ö†Ô∏è Moteur de suggestions non disponible")
                results['suggestions'] = False
        except Exception as e:
            logger.error(f"‚ùå Test suggestions √©chou√©: {e}")
            results['suggestions'] = False
        
        # R√©sum√© des tests
        logger.info("\nüìä R√âSUM√â DES TESTS:")
        total_tests = len(results)
        passed_tests = sum(1 for result in results.values() if result)
        
        for test_name, result in results.items():
            status = "‚úÖ PASS" if result else "‚ùå FAIL"
            logger.info(f"  {test_name}: {status}")
        
        logger.info(f"\nüéØ Score: {passed_tests}/{total_tests} tests r√©ussis ({passed_tests/total_tests*100:.1f}%)")
        
        return results
    
    async def run_demo_sequence(self):
        """Ex√©cute une s√©quence de d√©monstration"""
        logger.info("üé¨ Lancement de la d√©monstration JARVIS...")
        
        try:
            # 1. Capture et analyse de l'√©cran actuel
            logger.info("üì∏ 1. Capture et analyse de l'√©cran...")
            screenshot = await self.modules['screen_capture'].capture()
            if screenshot:
                analysis = await self.modules['vision_analyzer'].analyze_screen(screenshot.image)
                logger.info(f"üìã Analyse: {analysis.description[:200]}...")
                
                # OCR du texte visible
                ocr_result = await self.modules['ocr'].extract_text(screenshot.image)
                logger.info(f"üìù Texte d√©tect√©: {len(ocr_result.words)} mots")
            
            # 2. D√©tection des applications actives
            logger.info("üîç 2. D√©tection des applications...")
            active_app = await self.modules['app_detector'].get_active_application()
            if active_app:
                logger.info(f"üì± Application active: {active_app.name}")
                if active_app.main_window:
                    logger.info(f"ü™ü Fen√™tre: {active_app.main_window.title}")
            
            # 3. Planification d'une t√¢che simple
            logger.info("üìã 3. Planification d'une t√¢che...")
            sequence = await self.modules['planner'].parse_natural_command(
                "Analyze the current screen and describe what I can do"
            )
            
            logger.info(f"üìù S√©quence planifi√©e: {sequence.name}")
            for i, action in enumerate(sequence.actions[:3]):  # Montrer les 3 premi√®res
                logger.info(f"  {i+1}. {action.type.value}: {action.description}")
            
            # 4. Test d'interaction IA (si disponible)
            if self.modules['ollama'].is_available:
                logger.info("ü§ñ 4. Interaction avec l'IA...")
                
                # Analyser l'√©cran avec l'IA
                if screenshot:
                    import base64
                    import io
                    
                    # Convertir l'image en base64
                    buffer = io.BytesIO()
                    screenshot.image.save(buffer, format='PNG')
                    image_b64 = base64.b64encode(buffer.getvalue()).decode()
                    
                    ai_analysis = await self.modules['ollama'].analyze_screen(
                        image_b64, 
                        "D√©cris ce que tu vois et sugg√®re des actions possibles"
                    )
                    
                    if ai_analysis.success:
                        logger.info(f"üß† Analyse IA: {ai_analysis.content[:300]}...")
            
            logger.success("‚úÖ D√©monstration termin√©e avec succ√®s!")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur pendant la d√©monstration: {e}")
    
    async def interactive_mode(self):
        """Mode interactif avec l'utilisateur"""
        logger.info("üéÆ Mode interactif JARVIS activ√©")
        logger.info("Tapez 'help' pour voir les commandes disponibles, 'quit' pour quitter")
        
        while True:
            try:
                # Prompt utilisateur
                command = input("\nü§ñ JARVIS> ").strip()
                
                if not command:
                    continue
                
                if command.lower() in ['quit', 'exit', 'q']:
                    logger.info("üëã Au revoir!")
                    break
                
                elif command.lower() == 'help':
                    self._show_help()
                
                elif command.lower() == 'status':
                    await self._show_status()
                
                elif command.lower() == 'screenshot':
                    await self._take_screenshot()
                
                elif command.lower() == 'analyze':
                    await self._analyze_current_screen()
                
                elif command.lower() == 'apps':
                    await self._show_running_apps()
                
                elif command.startswith('chat '):
                    await self._chat_with_ai(command[5:])
                
                elif command.startswith('plan '):
                    await self._plan_command(command[5:])
                
                else:
                    # Commande conversationnelle naturelle
                    await self._chat_naturally(command)
                
            except KeyboardInterrupt:
                logger.info("\nüëã Arr√™t demand√© par l'utilisateur")
                break
            except Exception as e:
                logger.error(f"‚ùå Erreur: {e}")
    
    def _show_help(self):
        """Affiche l'aide"""
        help_text = """
ü§ñ COMMANDES JARVIS DISPONIBLES:

Commandes syst√®me:
  help                    - Affiche cette aide
  status                  - Statut des modules
  quit/exit/q            - Quitter JARVIS

Vision et analyse:
  screenshot             - Prendre une capture d'√©cran
  analyze                - Analyser l'√©cran actuel
  
Applications:
  apps                   - Lister les applications en cours

IA et planification:
  chat <message>         - Discuter avec JARVIS
  plan <commande>        - Planifier une commande
  
Commandes naturelles:
  Vous pouvez aussi donner des commandes en langage naturel:
  - "Take a screenshot"
  - "Open notepad"
  - "Search for Python on Google"
  - "Close the current window"
"""
        print(help_text)
    
    async def _show_status(self):
        """Affiche le statut des modules"""
        logger.info("üìä STATUT DES MODULES JARVIS:")
        
        for name, module in self.modules.items():
            status = "‚úÖ OK" if module else "‚ùå ERREUR"
            
            # Informations sp√©cifiques par module
            extra_info = ""
            
            if name == 'ollama' and module:
                extra_info = f" ({len(module.get_available_models())} mod√®les)"
            elif name == 'screen_capture' and module:
                info = module.get_screen_info()
                extra_info = f" ({len(info['monitors'])} moniteur(s))"
            elif name == 'app_detector' and module:
                stats = module.get_application_stats()
                extra_info = f" ({stats.get('total_applications', 0)} apps)"
            
            logger.info(f"  {name}: {status}{extra_info}")
    
    async def _take_screenshot(self):
        """Prend une capture d'√©cran"""
        try:
            logger.info("üì∏ Prise de capture d'√©cran...")
            screenshot = await self.modules['screen_capture'].capture()
            if screenshot:
                filename = f"jarvis_screenshot_{int(time.time())}.png"
                screenshot.save(filename)
                logger.success(f"‚úÖ Capture sauv√©e: {filename}")
            else:
                logger.error("‚ùå √âchec de la capture")
        except Exception as e:
            logger.error(f"‚ùå Erreur capture: {e}")
    
    async def _analyze_current_screen(self):
        """Analyse l'√©cran actuel"""
        try:
            logger.info("üëÅÔ∏è  Analyse de l'√©cran...")
            screenshot = await self.modules['screen_capture'].capture()
            if screenshot:
                analysis = await self.modules['vision_analyzer'].analyze_screen(screenshot.image)
                
                logger.info(f"üìã Type de sc√®ne: {analysis.scene_type}")
                logger.info(f"üìù Description: {analysis.description}")
                logger.info(f"üî≤ √âl√©ments d√©tect√©s: {len(analysis.ui_elements)}")
                
                if analysis.actions_suggested:
                    logger.info("üí° Actions sugg√©r√©es:")
                    for action in analysis.actions_suggested[:3]:
                        logger.info(f"  - {action}")
            else:
                logger.error("‚ùå Impossible de capturer l'√©cran")
        except Exception as e:
            logger.error(f"‚ùå Erreur analyse: {e}")
    
    async def _show_running_apps(self):
        """Affiche les applications en cours"""
        try:
            logger.info("üîç Applications en cours d'ex√©cution:")
            apps = await self.modules['app_detector'].get_running_applications()
            
            for i, app in enumerate(apps[:10]):  # Top 10
                status = "üü¢ ACTIVE" if app.is_active else "‚ö™"
                windows = f" ({len(app.windows)} fen√™tres)" if app.windows else ""
                logger.info(f"  {status} {app.name} - {app.memory_usage}MB{windows}")
            
            if len(apps) > 10:
                logger.info(f"  ... et {len(apps) - 10} autres applications")
                
        except Exception as e:
            logger.error(f"‚ùå Erreur listage apps: {e}")
    
    async def _chat_with_ai(self, message: str):
        """Discute avec l'IA"""
        try:
            if not self.modules['ollama'].is_available:
                logger.warning("‚ö†Ô∏è  Service Ollama non disponible")
                return
            
            logger.info(f"ü§ñ Discussion avec JARVIS: {message}")
            response = await self.modules['ollama'].chat(message)
            
            if response.success:
                logger.info(f"üí¨ JARVIS: {response.content}")
            else:
                logger.error(f"‚ùå Erreur IA: {response.error}")
        except Exception as e:
            logger.error(f"‚ùå Erreur chat: {e}")
    
    async def _plan_command(self, command: str):
        """Planifie une commande"""
        try:
            logger.info(f"üìã Planification: {command}")
            sequence = await self.modules['planner'].parse_natural_command(command)
            
            logger.info(f"üìù S√©quence: {sequence.name}")
            logger.info(f"üìÉ Description: {sequence.description}")
            logger.info(f"üî¢ Actions ({len(sequence.actions)}):")
            
            for i, action in enumerate(sequence.actions):
                logger.info(f"  {i+1}. {action.type.value}: {action.description}")
                if action.parameters:
                    logger.info(f"     Param√®tres: {action.parameters}")
        except Exception as e:
            logger.error(f"‚ùå Erreur planification: {e}")
    
    async def _chat_naturally(self, command: str):
        """Conversation naturelle avec JARVIS"""
        try:
            logger.info(f"üí¨ Conversation: {command}")
            
            # Utiliser l'agent pour traiter la conversation
            result = await self.agent.process_command(command, mode="conversation")
            
            if result.get("success"):
                response = result.get("response", "")
                action_executed = result.get("action_executed", False)
                
                # Afficher la r√©ponse de JARVIS
                print(f"\nü§ñ JARVIS: {response}")
                
                if action_executed:
                    print("‚úÖ J'ai ex√©cut√© l'action demand√©e.")
                    
            else:
                print(f"‚ùå Erreur: {result.get('error', 'Erreur inconnue')}")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur conversation: {e}")
            print(f"‚ùå D√©sol√©, j'ai rencontr√© un probl√®me: {e}")
    
    async def _execute_natural_command(self, command: str):
        """Ex√©cute une commande en langage naturel (legacy)"""
        try:
            logger.info(f"üéØ Ex√©cution de la commande: {command}")
            
            # Pour l'instant, juste planifier (l'ex√©cution sera impl√©ment√©e plus tard)
            sequence = await self.modules['planner'].parse_natural_command(command)
            
            logger.info(f"üìã Commande planifi√©e: {sequence.name}")
            logger.info(f"‚ö†Ô∏è  Ex√©cution automatique pas encore impl√©ment√©e")
            logger.info("üí° Utilisez 'plan <commande>' pour voir le plan d'action")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur ex√©cution: {e}")

    def print_help(self):
        """Affiche l'aide d'utilisation"""
        help_text = """
ü§ñ JARVIS - Assistant IA Autonome pour Windows

Usage: python main.py [options]

Options:
  --demo          Lance une d√©monstration interactive
  --test          Ex√©cute tous les tests de modules
  --voice         Lance le mode vocal interactif
  --autocomplete  Test le syst√®me d'autocompl√©tion
  --config PATH   Utilise un fichier de configuration personnalis√©
  --debug         Active le mode debug avec logs d√©taill√©s
  --sandbox       Active le mode sandbox (s√©curis√©)
  --help          Affiche cette aide

Modes d'op√©ration:
  ‚Ä¢ Mode Interactif: Interface en ligne de commande
  ‚Ä¢ Mode Vocal: Interaction par reconnaissance vocale
  ‚Ä¢ Mode D√©monstration: Tests automatis√©s et d√©monstrations
  ‚Ä¢ Mode Sandbox: Ex√©cution s√©curis√©e avec restrictions

Fonctionnalit√©s Phase 1:
  ‚úÖ Vision: Capture d'√©cran, OCR, analyse visuelle
  ‚úÖ Contr√¥le: Souris, clavier, d√©tection d'applications
  ‚úÖ IA: Service Ollama, planification d'actions

Fonctionnalit√©s Phase 2:
  ‚úÖ Interface vocale: Reconnaissance et synth√®se vocale
  ‚úÖ Autocompl√©tion globale: Suggestions intelligentes
  ‚úÖ M√©moire persistante: Apprentissage des habitudes
  ‚úÖ Ex√©cuteur d'actions: Automatisation s√©curis√©e
  üîÑ Interface moderne: UI Electron + React

Exemples:
  python main.py --demo             # D√©monstration compl√®te
  python main.py --voice            # Mode vocal interactif
  python main.py --autocomplete     # Test autocompl√©tion
  python main.py --test --debug     # Tests avec logs d√©taill√©s
  python main.py --sandbox          # Mode s√©curis√©
"""
        print(help_text)

async def main():
    """Fonction principale"""
    parser = argparse.ArgumentParser(description="JARVIS - Agent IA Autonome")
    parser.add_argument('--demo', action='store_true', help='Mode d√©monstration')
    parser.add_argument('--voice', action='store_true', help='Lance le mode vocal')
    parser.add_argument('--autocomplete', action='store_true', help='Test autocompl√©tion')
    parser.add_argument('--tools', action='store_true', help='Test syst√®me d\'outils')
    parser.add_argument('--test', action='store_true', help='Ex√©cuter les tests')
    parser.add_argument('--command', type=str, help='Ex√©cuter une commande directe')
    parser.add_argument('--config', type=str, help='Fichier de configuration')
    
    args = parser.parse_args()
    
    # Banni√®re de d√©marrage
    print("""
    ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
    ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    
    ü§ñ Agent IA Autonome pour Windows
    Version 1.0.0 - Phase de d√©veloppement
    """)
    
    # Initialisation
    demo = JarvisDemo()
    
    if not await demo.initialize_all_modules():
        logger.error("‚ùå Impossible d'initialiser JARVIS")
        return 1
    
    # Mode choisi
    if args.test:
        await demo.run_basic_tests()
    elif args.voice:
        await demo.run_voice_mode()
    elif args.autocomplete:
        await demo.test_autocomplete_system()
    elif args.tools:
        await demo.test_tools_system()
    
    elif args.demo:
        await demo.run_demo_sequence()
    
    elif args.command:
        # Ex√©cuter une commande directe
        try:
            sequence = await demo.modules['planner'].parse_natural_command(args.command)
            logger.info(f"üìã Commande planifi√©e: {sequence.name}")
            
            for i, action in enumerate(sequence.actions):
                logger.info(f"  {i+1}. {action.type.value}: {action.description}")
        except Exception as e:
            logger.error(f"‚ùå Erreur commande: {e}")
    
    else:
        # Mode interactif par d√©faut
        await demo.interactive_mode()
    
    return 0

if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        logger.info("\nüëã JARVIS arr√™t√© par l'utilisateur")
        sys.exit(0)
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale: {e}")
        sys.exit(1)