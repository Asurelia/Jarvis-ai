#!/usr/bin/env python3
"""
JARVIS AI - Installation automatis√©e compl√®te
Installe et configure automatiquement tout l'environnement JARVIS
"""

import os
import sys
import subprocess
import platform
import json
import shutil
from pathlib import Path
from typing import List, Dict, Optional
import time
import logging

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('jarvis-install.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class Colors:
    """Codes couleur pour l'affichage terminal"""
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

class JarvisInstaller:
    def __init__(self):
        self.system = platform.system().lower()
        self.project_dir = Path(__file__).parent.absolute()
        self.errors = []
        self.installed_components = []
        
    def print_banner(self):
        """Affiche la banni√®re d'installation"""
        banner = f"""
{Colors.HEADER}{Colors.BOLD}
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë            JARVIS AI INSTALLER           ‚ïë
‚ïë         Installation Automatis√©e         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
{Colors.ENDC}
Syst√®me: {self.system.capitalize()}
R√©pertoire: {self.project_dir}
"""
        print(banner)

    def check_prerequisites(self) -> bool:
        """V√©rifie les pr√©requis syst√®me"""
        logger.info("üîç V√©rification des pr√©requis...")
        
        prerequisites = {
            'python': {'cmd': 'python --version', 'min_version': '3.8'},
            'docker': {'cmd': 'docker --version', 'required': True},
            'docker-compose': {'cmd': 'docker-compose --version', 'required': True},
            'git': {'cmd': 'git --version', 'required': True},
        }
        
        if self.system == 'windows':
            prerequisites['python']['cmd'] = 'python --version'
        
        missing = []
        for name, config in prerequisites.items():
            try:
                result = subprocess.run(
                    config['cmd'].split(), 
                    capture_output=True, 
                    text=True, 
                    check=True
                )
                print(f"{Colors.OKGREEN}‚úì{Colors.ENDC} {name}: {result.stdout.strip()}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                if config.get('required', False):
                    missing.append(name)
                    print(f"{Colors.FAIL}‚úó{Colors.ENDC} {name}: Non trouv√©")
                else:
                    print(f"{Colors.WARNING}‚ö†{Colors.ENDC} {name}: Non trouv√© (optionnel)")
        
        if missing:
            print(f"\n{Colors.FAIL}Pr√©requis manquants:{Colors.ENDC}")
            for item in missing:
                print(f"  - {item}")
            print(f"\n{Colors.WARNING}Veuillez installer les pr√©requis manquants et relancer l'installation.{Colors.ENDC}")
            return False
            
        return True

    def install_python_dependencies(self) -> bool:
        """Installe les d√©pendances Python"""
        logger.info("üì¶ Installation des d√©pendances Python...")
        
        try:
            # Cr√©er l'environnement virtuel si n√©cessaire
            venv_path = self.project_dir / 'venv'
            if not venv_path.exists():
                print(f"{Colors.OKBLUE}Cr√©ation de l'environnement virtuel...{Colors.ENDC}")
                subprocess.run([sys.executable, '-m', 'venv', str(venv_path)], check=True)
            
            # Activer l'environnement virtuel
            if self.system == 'windows':
                pip_cmd = str(venv_path / 'Scripts' / 'pip.exe')
                python_cmd = str(venv_path / 'Scripts' / 'python.exe')
            else:
                pip_cmd = str(venv_path / 'bin' / 'pip')
                python_cmd = str(venv_path / 'bin' / 'python')
            
            # Mise √† jour de pip
            subprocess.run([python_cmd, '-m', 'pip', 'install', '--upgrade', 'pip'], check=True)
            
            # Installation des d√©pendances principales
            requirements_files = [
                'requirements.txt',
                'local-interface/requirements.txt'
            ]
            
            for req_file in requirements_files:
                req_path = self.project_dir / req_file
                if req_path.exists():
                    print(f"  üìã Installation de {req_file}...")
                    subprocess.run([pip_cmd, 'install', '-r', str(req_path)], check=True)
            
            # Installation des d√©pendances de d√©veloppement
            dev_packages = ['pytest', 'black', 'flake8', 'pre-commit']
            subprocess.run([pip_cmd, 'install'] + dev_packages, check=True)
            
            print(f"{Colors.OKGREEN}‚úì{Colors.ENDC} D√©pendances Python install√©es")
            self.installed_components.append('Python Dependencies')
            return True
            
        except subprocess.CalledProcessError as e:
            error_msg = f"Erreur lors de l'installation des d√©pendances Python: {e}"
            logger.error(error_msg)
            self.errors.append(error_msg)
            return False

    def setup_docker_environment(self) -> bool:
        """Configure l'environnement Docker"""
        logger.info("üê≥ Configuration de l'environnement Docker...")
        
        try:
            # V√©rifier que Docker est d√©marr√©
            subprocess.run(['docker', 'info'], capture_output=True, check=True)
            
            # Construire les images Docker
            docker_services = [
                'brain-api',
                'stt-service', 
                'tts-service',
                'system-control',
                'terminal-service',
                'mcp-gateway',
                'autocomplete-service'
            ]
            
            for service in docker_services:
                service_path = self.project_dir / 'services' / service
                if service_path.exists() and (service_path / 'Dockerfile').exists():
                    print(f"  üî® Construction de l'image {service}...")
                    subprocess.run([
                        'docker', 'build', 
                        '-t', f'jarvis-{service}',
                        str(service_path)
                    ], check=True, cwd=str(self.project_dir))
            
            # Configuration des r√©seaux Docker
            try:
                subprocess.run(['docker', 'network', 'create', 'jarvis-network'], 
                             capture_output=True, check=True)
            except subprocess.CalledProcessError:
                # Le r√©seau existe probablement d√©j√†
                pass
            
            print(f"{Colors.OKGREEN}‚úì{Colors.ENDC} Environnement Docker configur√©")
            self.installed_components.append('Docker Environment')
            return True
            
        except subprocess.CalledProcessError as e:
            error_msg = f"Erreur lors de la configuration Docker: {e}"
            logger.error(error_msg)
            self.errors.append(error_msg)
            return False

    def install_nodejs_dependencies(self) -> bool:
        """Installe les d√©pendances Node.js pour l'interface"""
        logger.info("üü¢ Installation des d√©pendances Node.js...")
        
        try:
            ui_path = self.project_dir / 'ui'
            if not ui_path.exists():
                print(f"{Colors.WARNING}‚ö†{Colors.ENDC} R√©pertoire UI non trouv√©, ignorer...")
                return True
            
            # V√©rifier npm
            subprocess.run(['npm', '--version'], capture_output=True, check=True)
            
            # Installation des d√©pendances
            print(f"  üì¶ Installation des packages npm...")
            subprocess.run(['npm', 'install'], cwd=str(ui_path), check=True)
            
            # Build de production
            print(f"  üî® Build de l'interface...")
            subprocess.run(['npm', 'run', 'build'], cwd=str(ui_path), check=True)
            
            print(f"{Colors.OKGREEN}‚úì{Colors.ENDC} Interface utilisateur install√©e")
            self.installed_components.append('UI Dependencies')
            return True
            
        except (subprocess.CalledProcessError, FileNotFoundError) as e:
            print(f"{Colors.WARNING}‚ö†{Colors.ENDC} Node.js non disponible, interface web d√©sactiv√©e")
            return True

    def setup_configuration(self) -> bool:
        """Configure les fichiers de configuration"""
        logger.info("‚öôÔ∏è Configuration des fichiers...")
        
        try:
            # Cr√©er les r√©pertoires n√©cessaires
            directories = [
                'logs',
                'cache', 
                'memory',
                'models',
                'data'
            ]
            
            for directory in directories:
                dir_path = self.project_dir / directory
                dir_path.mkdir(exist_ok=True)
            
            # Configuration par d√©faut
            config = {
                "system": {
                    "debug": False,
                    "log_level": "INFO",
                    "auto_start": True
                },
                "services": {
                    "brain_api": {"port": 5000, "enabled": True},
                    "stt_service": {"port": 5001, "enabled": True},
                    "tts_service": {"port": 5002, "enabled": True},
                    "system_control": {"port": 5004, "enabled": True},
                    "terminal_service": {"port": 5005, "enabled": True},
                    "mcp_gateway": {"port": 5006, "enabled": True},
                    "autocomplete_service": {"port": 5007, "enabled": True}
                },
                "ai": {
                    "model": "llama3.2:latest",
                    "temperature": 0.7,
                    "max_tokens": 2048
                },
                "voice": {
                    "input_device": "default",
                    "output_device": "default",
                    "wake_word": "jarvis"
                }
            }
            
            config_path = self.project_dir / 'config' / 'jarvis.json'
            config_path.parent.mkdir(exist_ok=True)
            
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)
            
            print(f"{Colors.OKGREEN}‚úì{Colors.ENDC} Configuration initialis√©e")
            self.installed_components.append('Configuration')
            return True
            
        except Exception as e:
            error_msg = f"Erreur lors de la configuration: {e}"
            logger.error(error_msg)
            self.errors.append(error_msg)
            return False

    def setup_voice_bridge(self) -> bool:
        """Configure le pont vocal local"""
        logger.info("üé§ Configuration du pont vocal...")
        
        try:
            voice_bridge_path = self.project_dir / 'local-interface' / 'voice-bridge.py'
            if not voice_bridge_path.exists():
                print(f"{Colors.WARNING}‚ö†{Colors.ENDC} voice-bridge.py non trouv√©")
                return True
            
            # Cr√©er un script de lancement pour le pont vocal
            if self.system == 'windows':
                launcher_content = f"""@echo off
cd /d "{self.project_dir}"
call venv\\Scripts\\activate
python local-interface\\voice-bridge.py
pause
"""
                launcher_path = self.project_dir / 'start-voice-bridge.bat'
            else:
                launcher_content = f"""#!/bin/bash
cd "{self.project_dir}"
source venv/bin/activate
python local-interface/voice-bridge.py
"""
                launcher_path = self.project_dir / 'start-voice-bridge.sh'
            
            with open(launcher_path, 'w') as f:
                f.write(launcher_content)
            
            if self.system != 'windows':
                os.chmod(launcher_path, 0o755)
            
            print(f"{Colors.OKGREEN}‚úì{Colors.ENDC} Pont vocal configur√©")
            self.installed_components.append('Voice Bridge')
            return True
            
        except Exception as e:
            error_msg = f"Erreur lors de la configuration du pont vocal: {e}"
            logger.error(error_msg)
            self.errors.append(error_msg)
            return False

    def create_launch_scripts(self) -> bool:
        """Cr√©e les scripts de lancement automatique"""
        logger.info("üöÄ Cr√©ation des scripts de lancement...")
        
        try:
            # Script de lancement principal Windows
            if self.system == 'windows':
                windows_script = f"""@echo off
title JARVIS AI - Lancement Automatique
echo.
echo ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
echo ‚ïë            JARVIS AI STARTUP             ‚ïë
echo ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
echo.

cd /d "{self.project_dir}"

echo [1/4] Demarrage des services Docker...
docker-compose up -d
if errorlevel 1 (
    echo ERREUR: Echec du demarrage Docker
    pause
    exit /b 1
)

echo [2/4] Attente de l'initialisation des services...
timeout /t 10 /nobreak >nul

echo [3/4] Demarrage du pont vocal...
start "Voice Bridge" start-voice-bridge.bat

echo [4/4] Demarrage de l'interface principale...
call venv\\Scripts\\activate
start "JARVIS Main" python start_jarvis.py

echo.
echo ‚úì JARVIS AI demarre avec succes!
echo   - Interface web: http://localhost:3000
echo   - API principale: http://localhost:5000
echo   - Documentation: http://localhost:5000/docs
echo.
echo Appuyez sur une touche pour fermer cette fenetre...
pause >nul
"""
                with open(self.project_dir / 'launch-jarvis.bat', 'w') as f:
                    f.write(windows_script)
            
            # Script de lancement principal Linux/Mac
            unix_script = f"""#!/bin/bash
echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
echo "‚ïë            JARVIS AI STARTUP             ‚ïë"
echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
echo

cd "{self.project_dir}"

echo "[1/4] D√©marrage des services Docker..."
docker-compose up -d
if [ $? -ne 0 ]; then
    echo "ERREUR: √âchec du d√©marrage Docker"
    exit 1
fi

echo "[2/4] Attente de l'initialisation des services..."
sleep 10

echo "[3/4] D√©marrage du pont vocal..."
./start-voice-bridge.sh &

echo "[4/4] D√©marrage de l'interface principale..."
source venv/bin/activate
python start_jarvis.py &

echo
echo "‚úì JARVIS AI d√©marr√© avec succ√®s!"
echo "  - Interface web: http://localhost:3000"
echo "  - API principale: http://localhost:5000"
echo "  - Documentation: http://localhost:5000/docs"
echo
"""
            with open(self.project_dir / 'launch-jarvis.sh', 'w') as f:
                f.write(unix_script)
            os.chmod(self.project_dir / 'launch-jarvis.sh', 0o755)
            
            # Script d'arr√™t
            stop_script = """#!/bin/bash
echo "Arr√™t de JARVIS AI..."
docker-compose down
pkill -f voice-bridge.py
pkill -f start_jarvis.py
echo "‚úì JARVIS AI arr√™t√©"
"""
            with open(self.project_dir / 'stop-jarvis.sh', 'w') as f:
                f.write(stop_script)
            os.chmod(self.project_dir / 'stop-jarvis.sh', 0o755)
            
            print(f"{Colors.OKGREEN}‚úì{Colors.ENDC} Scripts de lancement cr√©√©s")
            self.installed_components.append('Launch Scripts')
            return True
            
        except Exception as e:
            error_msg = f"Erreur lors de la cr√©ation des scripts: {e}"
            logger.error(error_msg)
            self.errors.append(error_msg)
            return False

    def pull_ai_models(self) -> bool:
        """T√©l√©charge les mod√®les IA n√©cessaires"""
        logger.info("ü§ñ T√©l√©chargement des mod√®les IA...")
        
        try:
            # V√©rifier si Ollama est disponible
            try:
                subprocess.run(['ollama', 'version'], capture_output=True, check=True)
            except (subprocess.CalledProcessError, FileNotFoundError):
                print(f"{Colors.WARNING}‚ö†{Colors.ENDC} Ollama non install√©, mod√®les IA non t√©l√©charg√©s")
                return True
            
            # Mod√®les √† t√©l√©charger
            models = [
                'llama3.2:latest',
                'codellama:7b'
            ]
            
            for model in models:
                print(f"  üì• T√©l√©chargement de {model}...")
                try:
                    subprocess.run(['ollama', 'pull', model], check=True, timeout=600)
                except subprocess.TimeoutExpired:
                    print(f"{Colors.WARNING}‚ö†{Colors.ENDC} Timeout pour {model}, continuer...")
                except subprocess.CalledProcessError:
                    print(f"{Colors.WARNING}‚ö†{Colors.ENDC} √âchec du t√©l√©chargement de {model}")
            
            print(f"{Colors.OKGREEN}‚úì{Colors.ENDC} Mod√®les IA t√©l√©charg√©s")
            self.installed_components.append('AI Models')
            return True
            
        except Exception as e:
            error_msg = f"Erreur lors du t√©l√©chargement des mod√®les: {e}"
            logger.error(error_msg)
            return True  # Non bloquant

    def run_tests(self) -> bool:
        """Ex√©cute les tests de base"""
        logger.info("üß™ Ex√©cution des tests de validation...")
        
        try:
            # Test des imports Python
            test_imports = [
                'import fastapi',
                'import websockets', 
                'import pydantic',
                'import uvicorn'
            ]
            
            for test_import in test_imports:
                try:
                    subprocess.run([
                        sys.executable, '-c', test_import
                    ], check=True, capture_output=True, cwd=str(self.project_dir))
                except subprocess.CalledProcessError:
                    print(f"{Colors.WARNING}‚ö†{Colors.ENDC} Import √©chou√©: {test_import}")
            
            # Test de la configuration Docker
            try:
                result = subprocess.run([
                    'docker-compose', 'config'
                ], capture_output=True, text=True, cwd=str(self.project_dir))
                if result.returncode != 0:
                    print(f"{Colors.WARNING}‚ö†{Colors.ENDC} Configuration Docker invalide")
            except subprocess.CalledProcessError:
                print(f"{Colors.WARNING}‚ö†{Colors.ENDC} Impossible de valider Docker")
            
            print(f"{Colors.OKGREEN}‚úì{Colors.ENDC} Tests de validation termin√©s")
            return True
            
        except Exception as e:
            error_msg = f"Erreur lors des tests: {e}"
            logger.error(error_msg)
            return True  # Non bloquant

    def print_summary(self):
        """Affiche le r√©sum√© de l'installation"""
        print(f"\n{Colors.HEADER}{Colors.BOLD}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó{Colors.ENDC}")
        print(f"{Colors.HEADER}{Colors.BOLD}‚ïë              INSTALLATION TERMIN√âE            ‚ïë{Colors.ENDC}")
        print(f"{Colors.HEADER}{Colors.BOLD}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù{Colors.ENDC}")
        
        print(f"\n{Colors.OKGREEN}Composants install√©s:{Colors.ENDC}")
        for component in self.installed_components:
            print(f"  ‚úì {component}")
        
        if self.errors:
            print(f"\n{Colors.WARNING}Avertissements:{Colors.ENDC}")
            for error in self.errors:
                print(f"  ‚ö† {error}")
        
        print(f"\n{Colors.OKBLUE}Comment d√©marrer JARVIS:{Colors.ENDC}")
        if self.system == 'windows':
            print(f"  üìÑ Double-cliquez sur: launch-jarvis.bat")
        else:
            print(f"  üìÑ Ex√©cutez: ./launch-jarvis.sh")
        
        print(f"\n{Colors.OKBLUE}Acc√®s aux services:{Colors.ENDC}")
        print(f"  üåê Interface web: http://localhost:3000")
        print(f"  üîó API principale: http://localhost:5000")
        print(f"  üìö Documentation: http://localhost:5000/docs")
        
        print(f"\n{Colors.OKCYAN}Pour plus d'aide, consultez le README.md{Colors.ENDC}")

    def install(self):
        """Lance l'installation compl√®te"""
        self.print_banner()
        
        if not self.check_prerequisites():
            sys.exit(1)
        
        installation_steps = [
            ('D√©pendances Python', self.install_python_dependencies),
            ('Environnement Docker', self.setup_docker_environment), 
            ('Interface utilisateur', self.install_nodejs_dependencies),
            ('Configuration', self.setup_configuration),
            ('Pont vocal', self.setup_voice_bridge),
            ('Scripts de lancement', self.create_launch_scripts),
            ('Mod√®les IA', self.pull_ai_models),
            ('Tests de validation', self.run_tests)
        ]
        
        failed_steps = []
        for step_name, step_func in installation_steps:
            print(f"\n{Colors.OKBLUE}üîß {step_name}...{Colors.ENDC}")
            if not step_func():
                failed_steps.append(step_name)
        
        if failed_steps:
            print(f"\n{Colors.FAIL}√âtapes √©chou√©es:{Colors.ENDC}")
            for step in failed_steps:
                print(f"  ‚úó {step}")
            print(f"\n{Colors.WARNING}Installation partiellement r√©ussie. Consultez les logs pour plus de d√©tails.{Colors.ENDC}")
        
        self.print_summary()

if __name__ == '__main__':
    installer = JarvisInstaller()
    try:
        installer.install()
    except KeyboardInterrupt:
        print(f"\n{Colors.WARNING}Installation interrompue par l'utilisateur.{Colors.ENDC}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{Colors.FAIL}Erreur fatale: {e}{Colors.ENDC}")
        logger.exception("Erreur fatale lors de l'installation")
        sys.exit(1)